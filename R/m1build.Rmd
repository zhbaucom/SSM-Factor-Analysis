---
title: "Untitled"
output: html_document
---

```{r}
library(tidyverse)
source('functions/ffbsFactor.R')
seed <- 123
replaceMessage <- function(x, width = 80)
{
    message("\r", rep(" ", times = width - length(x)), "\r", appendLF = F)
    message(x, appendLF = F)
}
```

## Alpha and G matrix


```{r}
set.seed(seed)
its <- 10000
N <- 10
TT <-10
Q <- 4
K <- 8

sigeps2 <- 1
sigeta2 <- 1
gvec <- seq(0, 1, length.out = K)

V <- diag(sigeps2, K, K)
W <- diag(sigeta2, Q, Q)


GLoadings <- map(1:8, ~sample(c(sample(c(0, 0, 0, 1), 3), 1))) %>%
  do.call('rbind', .)

G <- c(
  runif(K*Q, 0, 20)
) %>%
  matrix(K, Q) * GLoadings


mu_qs <- matrix(0, K, Q)
# mu_qs <- G
var_qs <- 10


ITSKEEPER <- matrix(nrow = 500, ncol = 500)

i <- 1  


vcovWish <- array(NA, dim = c(K, K, its))
  
wcovWish <- array(NA, dim = c(Q, Q, its))

###Need another way to set "TT", not ncol (y)
prior.nu.eta <- K - 1 + 0.01
## prior.nu.eta <- cs + 1
prior.Gamma.eta <- diag(0.01, K)
## prior.Gamma.eta <- diag(1, cs)

a0 <- 0.01
b0 <- 0.01
c0 <- 0.01
d0 <- 0.01

Neta <- N * TT - N




etas <- rnorm(TT*N*Q, sd = sqrt(sigeta2)) %>%
  array(dim = c(TT,Q,N))

epsilon <- rnorm(TT*N*K, sd = sqrt(sigeps2)) %>%
  array(dim = c(K,TT,N))

alphas <- apply(etas, c(2,3), cumsum)
alphas <- lapply(1:N, function(i)alphas[,,i])


y <- lapply(1:N, function(i){
  tcrossprod(G, alphas[[i]]) + epsilon[,,i]
})

alpha.star <- lapply(alphas, t)


G.star <- mu_qs
# G.star[1,1] <- 0

G.track <- array(dim = c(dim(G), its))

k <- 1
q <- 2
qtil <- which((1:Q) != q)



i <- 1

ybig <- do.call("cbind", y)
alpha.track <- list()

for(i in 1:its){
  
  ### G transofrmed Alphas
  alpha.star <- alpha.track[[i]] <- lapply(y, function(yout)ffbs.joint(y = yout, G = G.star, V = V, W = W, m0 = 0, C0 = diag(10, Q, Q))$x)


  ### Posterior of G
  abig <- do.call("cbind", alpha.star)


  aybig <- tcrossprod(ybig, abig)

  ata.inv <-  solve(tcrossprod(abig)/sigeps2 + diag(1/var_qs, Q, Q))
  mu.g <- (mu_qs/var_qs + aybig/sigeps2) %*% ata.inv


  G.track[,,i] <- G.star <- abs((lapply(1:K, function(k){
    mvtnorm::rmvnorm(1, mean = mu.g[k,], sigma = ata.inv)
  }) %>%
    do.call("rbind", .)) * GLoadings)
  


  ### Variances
  if(i > 500){
    fp <- lapply(1:N, function(i){
      apply(alpha.star[[i]], 1, function(z)diff(z))
      
    }) %>%
      do.call("rbind", .) %>%
      crossprod()
    
    
    W <- cov2cor(cIRT::riwishart(Neta, fp))
    
    wcovWish[,,i] <- W
  }
  
  # 
  # 
  # W <- diag(sapply(diag(fp), function(x){
  #   1/rgamma(1, (Neta/ 2 + a0), (b0 + x/ 2))
  # }))
  # 
  # wcovWish[,,i] <- W
  
  
  ###### Sigma eps

  or <- lapply(1:N, function(i){
    (y[[i]] - G.star %*% alpha.star[[i]])^2
  })  %>%
    do.call("cbind", .) %>%
    apply(1, function(x)sum((x)))


  sigma2.eps.star <- sapply(or, function(x)1/rgamma(1, ((N*TT)/2 +c0), d0+x/2))
  V <- vcovWish[,,i] <-sigma2.eps.star * diag(K)

  if((i %% 10) == 0)replaceMessage(i)
    
}



```



```{r}
apply(wcovWish, 1:2,mean, na.rm = TRUE) %>%
  cov2cor()
apply(wcovWish, 1:2,quantile, .025, na.rm = TRUE) %>%
  cov2cor()
```





```{r}
covered <- matrix(0, K, Q)
for(kp in 1:K){
  for(qp in 1:Q){
    ci <- quantile(G.track[kp,qp,], c(0.025, 0.975), na.rm = T)
    covered[kp, qp] <- ci[1] < G[kp,qp] & ci[2] > G[kp,qp]
    plot(
      G.track[kp,qp,],
      main = paste(
        kp, ", ", qp, "    ",
        round(G[kp,qp], 3),
        ": (",
        paste( round(ci, 3), collapse = ", "),
        ")",
        sep = ""
      )
    )
    abline(h = G[kp,qp], col = 'red')
  }
}


hist(apply(G.track, 1:2, mean) - G)

```



```{r}
subject <- sample(1:N, 1)
i <- sample(1:TT, 1)
j <- sample(1:K, 1)
lapply(alpha.track, function(x)x[[subject]][1,1]) %>%
  unlist() %>%
  plot(main = paste("Subject: ", subject, ", Time: ", j, ", Test: ", i, sep = ""))
abline(h = alphas[[subject]][1,1], col = 'red')
```







```{r}
ghat <- (G.track[,,5000:10000] %>%
  apply(1:2, mean))

ghat
G 
```

```{r}
lcl <- apply(G.track[,,5000:10000], 1:2, quantile, .025)
ucl <- apply(G.track[,,5000:10000], 1:2, quantile, .975)
lcl[lcl < 0] <- 0
ucl[ucl < 0] <- 0

lcl/rowSums(abs(lcl)) < abs(G)/rowSums(abs(G)) & abs(G)/rowSums(abs(G)) < ucl/rowSums(abs(ucl)) 

abs(G)/rowSums(abs(G))
```

